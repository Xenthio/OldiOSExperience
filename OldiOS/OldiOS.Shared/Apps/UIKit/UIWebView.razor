@using Microsoft.JSInterop
@using OldiOS.Shared.Services
@inject IJSRuntime JSRuntime
@inject IServiceProvider ServiceProvider
@implements IDisposable

<div @ref="containerRef" class="ui-webview-container" style="@Style">
    @if (!isNativeWebView)
    {
        <iframe src="@Url" class="ui-webview-iframe" frameborder="0"></iframe>
    }
    else if (!string.IsNullOrEmpty(SnapshotData))
    {
        <img src="@SnapshotData" class="ui-webview-snapshot" />
    }
    else
    {
        <div class="ui-webview-placeholder"></div>
    }
</div>

@code {
    public static bool ForceIframeMode { get; set; } = false;
    public static bool GhostMode { get; set; } = false;

    [Parameter] public string Url { get; set; } = "";
    [Parameter] public string Style { get; set; } = "";
    [Parameter] public EventCallback<string> OnUrlChanged { get; set; }

    private ElementReference containerRef;
    private IWebViewService? WebViewService;
    private string SnapshotData = "";
    private bool IsVisible = true;
    private DotNetObjectReference<UIWebView>? objRef;
    private global::System.Threading.Timer? _resizeDebounceTimer;
    private bool isNativeWebView;
    private string currentUrl;
    private bool _isReady = false;
    private bool _isGhostLoopRunning = false;

    protected override void OnInitialized()
    {
        try
        {
            WebViewService = ServiceProvider.GetService(typeof(IWebViewService)) as IWebViewService;
            if (WebViewService != null)
            {
                WebViewService.OnUrlChanged += HandleUrlChanged;
            }
        }
        catch { }

        UpdateNativeState();
        currentUrl = Url;
    }

    protected override async Task OnParametersSetAsync()
    {
        UpdateNativeState();

        if (Url != currentUrl)
        {
            currentUrl = Url;
            if (isNativeWebView)
            {
                WebViewService?.Navigate(Url);
            }
        }

        // Handle Ghost Mode
        if (isNativeWebView && WebViewService != null)
        {
            if (GhostMode)
            {
                WebViewService.SetOpacity(0.01);
                if (!_isGhostLoopRunning)
                {
                    _isGhostLoopRunning = true;
                    _ = RunGhostLoop();
                }
            }
            else
            {
                WebViewService.SetOpacity(1.0);
                _isGhostLoopRunning = false;
                if (string.IsNullOrEmpty(SnapshotData))
                {
                    // Clear snapshot if we were ghosting but now normal
                    // We rely on native view visibility
                }
            }
        }
    }

    private async Task RunGhostLoop()
    {
        while (GhostMode && isNativeWebView && WebViewService != null)
        {
            SnapshotData = await WebViewService.CaptureSnapshotAsync();
            StateHasChanged();
            await Task.Delay(100); // 10 FPS snapshot update
        }
        _isGhostLoopRunning = false;
        // Clean up when loop ends
        if (!GhostMode && isNativeWebView && WebViewService != null)
        {
            WebViewService.SetOpacity(1.0);
            SnapshotData = "";
            StateHasChanged();
            await UpdateNativeWebViewPosition();
        }
    }

    private void UpdateNativeState()
    {
        // Native if: Not browser AND Not forced iframe AND Service exists
        var shouldBeNative = !OperatingSystem.IsBrowser() && !ForceIframeMode && WebViewService != null;
        
        if (isNativeWebView != shouldBeNative)
        {
            isNativeWebView = shouldBeNative;
            if (!isNativeWebView && WebViewService != null)
            {
                WebViewService.Hide();
            }
        }
    }

    private void HandleUrlChanged(string newUrl)
    {
        InvokeAsync(() => OnUrlChanged.InvokeAsync(newUrl));
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            if (WebViewService != null)
            {
                objRef = DotNetObjectReference.Create(this);
                await JSRuntime.InvokeVoidAsync("startPositionTracking", containerRef, objRef);

                // Delay showing the native webview until the app opening animation is likely complete (approx 600ms)
                _ = Task.Delay(700).ContinueWith(async _ =>
                {
                    _isReady = true;
                    await InvokeAsync(async () =>
                    {
                        await UpdateNativeWebViewPosition();
                        StateHasChanged();
                    });
                });
            }
        }
    }

    [JSInvokable]
    public void OnResize(BoundingClientRect rect)
    {
        if (isNativeWebView && IsVisible && (string.IsNullOrEmpty(SnapshotData) || GhostMode))
        {
            // Only update if ready (animation complete)
            // In Ghost Mode, we still need the webview to be positioned correctly to capture snapshots
            if (!_isReady) return;

            if (rect.Width > 10 && rect.Height > 10)
            {
                WebViewService?.Show(Url, rect.X, rect.Y, rect.Width, rect.Height);
            }
            else
            {
                WebViewService?.Hide();
            }
        }
    }

    public async Task<string> GetSnapshotAsync()
    {
        if (isNativeWebView && WebViewService != null)
        {
            SnapshotData = await WebViewService.CaptureSnapshotAsync();
            WebViewService.Hide();
            StateHasChanged();
            return SnapshotData;
        }
        return "";
    }

    public void ClearSnapshot()
    {
        SnapshotData = "";
        StateHasChanged();
        // Trigger a resize check to reshow
        _ = UpdateNativeWebViewPosition();
    }

    public async Task Refresh()
    {
        await UpdateNativeWebViewPosition();
    }

    private async Task UpdateNativeWebViewPosition()
    {
        if (!_isReady || !isNativeWebView) return;

        try
        {
            var rect = await JSRuntime.InvokeAsync<BoundingClientRect>("getElementBoundingClientRect", containerRef);

            if (rect != null && rect.Width > 10)
            {
                WebViewService?.Show(Url, rect.X, rect.Y, rect.Width, rect.Height);
            }
        }
        catch { }
    }

    public void GoBack()
    {
        if (isNativeWebView)
            WebViewService?.GoBack();
    }

    public void GoForward()
    {
        if (isNativeWebView)
            WebViewService?.GoForward();
    }

    public void Navigate(string url)
    {
        Url = url;
        if (isNativeWebView)
        {
            WebViewService?.Navigate(url);
        }
        StateHasChanged();
    }

    public void Dispose()
    {
        _resizeDebounceTimer?.Dispose();
        if (WebViewService != null)
        {
            WebViewService.OnUrlChanged -= HandleUrlChanged;
            WebViewService.Hide();
        }
        objRef?.Dispose();
    }

    public class BoundingClientRect
    {
        public double X { get; set; }
        public double Y { get; set; }
        public double Width { get; set; }
        public double Height { get; set; }
        public double OffsetWidth { get; set; }
        public double OffsetHeight { get; set; }
    }
}
