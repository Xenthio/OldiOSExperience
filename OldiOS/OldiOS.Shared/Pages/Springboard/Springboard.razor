@using OldiOS.Shared.Models
@using OldiOS.Shared.Services
@inject SpringboardService SpringboardService
@inject BackgroundAppManager AppManager
@inject AnimationService AnimationService
@inject DisplaySettings DisplaySettings
@implements IDisposable

<div class="springboard-container @(isAppOpen ? "app-is-open" : "") @(isAppSwitcherVisible ? "switcher-visible" : "") @(DebugAnimationActive ? "debug-animation" : "") @(isLocked ? "locked" : "") @(isUnlocking ? "unlocking" : "")"
     style="--icon-rows: @DisplaySettings.GetIconRows(); --icon-columns: @DisplaySettings.GetIconColumns();">
    <!-- Wallpaper -->
    <div class="wallpaper" alt="Wallpaper" />

    <!-- Status Bar -->
    <OldiOS.Shared.System.StatusBar Style="OldiOS.Shared.System.StatusBarStyle.WhiteOnBlackEtch" />

    <!-- Pages Container (the part that swipes) -->
    <div class="springboard-pages-container"
         @ontouchstart="HandleTouchStart"
         @ontouchmove="HandleTouchMove"
         @ontouchend="HandleTouchEnd"
         @onmousedown="HandleMouseDown"
         @onmousemove="HandleMouseMove"
         @onmouseup="HandleMouseUp"
         @onmouseleave="HandleMouseUp">

        <div class="springboard-pages-filmstrip" style="@filmstripStyle">
            <!-- Spotlight Page (index -1) -->
            <div class="springboard-page spotlight-container">
                <OldiOS.Shared.Pages.Springboard.Components.Spotlight AllApps="AllApps" />
            </div>

            <!-- Regular App Pages -->
            @foreach (var page in Pages)
            {
                <div class="springboard-page">
                    @foreach (var app in page)
                    {
                        <OldiOS.Shared.Pages.Springboard.Components.AppIcon App="app" OnAppClick="HandleAppClick" />
                    }
                </div>
            }
        </div>
    </div>

    <!-- Page Indicator Dots -->
    <div class="page-indicator">
        @for (int i = 0; i < Pages.Count; i++)
        {
            <div class="dot @(i == currentPageIndex ? "active" : "")"></div>
        }
    </div>

    <!-- The Dock -->
    <div class="dock">
        <div class="dock-background"></div>
        <div class="dock-icons">
            @foreach (var app in DockApps)
            {
                <OldiOS.Shared.Pages.Springboard.Components.AppIcon App="app" OnAppClick="HandleAppClick" />
            }
        </div>
    </div>

    <!-- App Container for launching apps -->
    <OldiOS.Shared.Pages.Springboard.Components.AppContainer CurrentApp="@openedApp" OnClose="CloseApp" />

    <!-- App Switcher (multitasking tray) -->
    <OldiOS.Shared.Pages.Springboard.Components.AppSwitcher IsVisible="@isAppSwitcherVisible"
                                                            OnClose="HandleAppSwitcherClose"
                                                            OnAppSelected="HandleAppSwitcherSelect" />

    <!-- Lock Screen -->
    <OldiOS.Shared.Pages.Springboard.Components.LockScreen IsLocked="@isLocked" OnUnlocked="HandleUnlocked" />
</div>

@code {
    // --- PARAMETERS ---
    [Parameter]
    public bool DebugAnimationActive { get; set; } = false;

    // --- DATA from Services ---
    private List<List<AppInfo>> Pages => SpringboardService.Pages;
    private List<AppInfo> DockApps => SpringboardService.DockApps;
    private List<AppInfo> AllApps => SpringboardService.AllApps;
    private AppInfo? openedApp => AppManager.ForegroundApp?.App;
    private bool isAppOpen => openedApp != null;

    // --- STATE for SWIPING ---
    private int currentPageIndex = 0; // 0 = first app page, -1 = spotlight
    private double touchStartX = 0;
    private double touchCurrentX = 0;
    private double dragOffset = 0;
    private bool isDragging = false;
    private DateTime touchStartTime = DateTime.MinValue;
    private bool isAnimating = false;

    // New state for pure C# animation
    private double filmstripOffset = 0;
    private CancellationTokenSource? _animationCts;

    // Track recent touch positions for accurate velocity calculation
    private class TouchPoint
    {
        public double X { get; set; }
        public DateTime Time { get; set; }
    }
    private List<TouchPoint> recentTouchPoints = new List<TouchPoint>();
    private const int MaxTouchPointHistory = 10; // Keep last 10 points
    private const double VelocityTimeWindowMs = 100; // Calculate velocity from last 100ms

    // --- APP SWITCHER STATE ---
    private bool isAppSwitcherVisible = false;

    // --- LOCK SCREEN STATE ---
    private bool isLocked = true;
    private bool isUnlocking = false;

    // We now have spotlight page, so total pages = spotlight + app pages
    // Position: -1 (spotlight), 0 (page 1), 1 (page 2), etc.
    private string filmstripStyle => $"transform: translateX({filmstripOffset}px); transition: none;";

    protected override void OnInitialized()
    {
        // Initialize springboard layout via service
        SpringboardService.InitializeLayout();

        // Subscribe to app state changes
        AppManager.OnAppStatesChanged += HandleAppStateChanged;

        // Subscribe to resolution changes
        DisplaySettings.OnResolutionChanged += HandleResolutionChanged;

        // Set initial filmstrip position
        UpdateFilmstripOffset();
    }

    public void Dispose()
    {
        _animationCts?.Cancel();
        _animationCts?.Dispose();
        AppManager.OnAppStatesChanged -= HandleAppStateChanged;
        DisplaySettings.OnResolutionChanged -= HandleResolutionChanged;
    }

    private void HandleResolutionChanged()
    {
        // Reinitialize layout when resolution changes
        SpringboardService.InitializeLayout();
        UpdateFilmstripOffset();
        StateHasChanged();
    }

    private void HandleAppStateChanged()
    {
        StateHasChanged();
    }

    private async void HandleUnlocked()
    {
        // Start unlock animation - icons/dock fly in
        isUnlocking = true;
        StateHasChanged();

        // Wait for animation to complete
        await Task.Delay(400);

        // Finish unlock
        isLocked = false;
        isUnlocking = false;
        StateHasChanged();
    }

    private void HandleAppSwitcherClose()
    {
        isAppSwitcherVisible = false;
        StateHasChanged();
    }

    private void HandleAppSwitcherSelect(AppInfo app)
    {
        // Launch the selected app
        AppManager.LaunchApp(app);
        isAppSwitcherVisible = false;
        StateHasChanged();
    }

    // --- APP LAUNCHING ---
    private void HandleAppClick(AppInfo app)
    {
        SpringboardService.LaunchApp(app);
    }

    private void CloseApp()
    {
        AppManager.ReturnToSpringboard();
    }

    // Public methods to handle home button presses from parent
    public void HandleHomeButtonSinglePress()
    {
        if (isLocked)
        {
            // If locked, home button wakes the screen but doesn't unlock
            return;
        }

        // Single tap - normal home button behavior
        SpringboardService.HandleHomeButton();
        StateHasChanged();
    }

    public void HandleHomeButtonDoublePress()
    {
        if (isLocked)
        {
            return;
        }

        // Double-tap - show app switcher
        isAppSwitcherVisible = true;
        StateHasChanged();
    }

    public void HandleHomeButtonLongPress()
    {
        if (isLocked)
        {
            return;
        }

        // Long press - could activate Siri or voice control in the future
        // For now, do nothing
        StateHasChanged();
    }

    // --- TOUCH EVENT HANDLERS ---
    private void HandleTouchStart(TouchEventArgs e)
    {
        // Cancel any ongoing animation
        if (isAnimating)
        {
            _animationCts?.Cancel();
            isAnimating = false;
        }

        isDragging = true;

        // The new touch start position is the current finger position
        touchStartX = e.Touches[0].ClientX / DisplaySettings.SCALEFACTOR;

        // The filmstrip's current position becomes the new baseline.
        // We calculate the new currentPageIndex based on the current visual offset.
        var viewportWidth = DisplaySettings.Width;
        currentPageIndex = (int)Math.Round((-filmstripOffset / viewportWidth) - 1);

        // The drag offset starts from zero relative to the interrupted position.
        dragOffset = 0;

        touchStartTime = DateTime.Now;

        // Initialize touch point tracking
        recentTouchPoints.Clear();
        recentTouchPoints.Add(new TouchPoint { X = touchStartX, Time = DateTime.Now });
    }

    private void HandleTouchMove(TouchEventArgs e)
    {
        if (!isDragging) return;

        touchCurrentX = e.Touches[0].ClientX / DisplaySettings.SCALEFACTOR;
        var rawOffset = touchCurrentX - touchStartX;

        // Track touch position for velocity calculation
        var now = DateTime.Now;
        recentTouchPoints.Add(new TouchPoint { X = touchCurrentX, Time = now });

        // Keep only recent points (last MaxTouchPointHistory points)
        if (recentTouchPoints.Count > MaxTouchPointHistory)
        {
            recentTouchPoints.RemoveAt(0);
        }

        // Apply resistance at boundaries
        if ((rawOffset > 0 && currentPageIndex <= -1) || // Trying to go before spotlight
            (rawOffset < 0 && currentPageIndex >= Pages.Count - 1)) // Trying to go past last page
        {
            // Apply rubber-band resistance (reduce drag effect by 30%)
            dragOffset = rawOffset * 0.3;
        }
        else
        {
            dragOffset = rawOffset;
        }

        // Update UI during drag for smooth tracking
        UpdateFilmstripOffset();
        StateHasChanged();
    }

    private async void HandleTouchEnd(TouchEventArgs e)
    {
        if (!isDragging) return;
        isDragging = false;

        // Calculate velocity from recent movement (last VelocityTimeWindowMs)
        var now = DateTime.Now;
        var velocity = CalculateVelocity(now);

        // Get viewport width for threshold calculation
        var viewportWidth = DisplaySettings.Width;
        var halfPage = viewportWidth / 2.0;

        // Determine if we should change pages based on:
        // 1. Distance threshold (> 50% of screen width)
        // 2. Velocity threshold (> 0.8 pixels per ms, roughly 800px/s) - increased to be more selective
        // Only consider velocity if it's a fast flick (not a slow drag)
        var isFastFlick = Math.Abs(velocity) > 0.8;
        var shouldChangePage = Math.Abs(dragOffset) > halfPage || isFastFlick;

        var targetPageIndex = currentPageIndex;
        if (shouldChangePage)
        {
            if (dragOffset < 0 && currentPageIndex < Pages.Count - 1)
            {
                // Swiped left, go to next page
                targetPageIndex++;
            }
            else if (dragOffset > 0 && currentPageIndex > -1)
            {
                // Swiped right, go to previous page (can go to spotlight at -1)
                targetPageIndex--;
            }
        }

        // Animate to the final position (either new page or back to current)
        await AnimateToPage(targetPageIndex);
    }

    private double CalculateVelocity(DateTime now)
    {
        // Need at least 2 points to calculate velocity
        if (recentTouchPoints.Count < 2)
        {
            return 0;
        }

        // Find the oldest point within our time window
        var cutoffTime = now.AddMilliseconds(-VelocityTimeWindowMs);
        var relevantPoints = recentTouchPoints.Where(p => p.Time >= cutoffTime).ToList();

        // Need at least 2 points in the window
        if (relevantPoints.Count < 2)
        {
            // Fall back to using all points if we don't have enough recent ones
            relevantPoints = recentTouchPoints;
        }

        if (relevantPoints.Count < 2)
        {
            return 0;
        }

        // Calculate velocity from first to last point in the window
        var firstPoint = relevantPoints[0];
        var lastPoint = relevantPoints[relevantPoints.Count - 1];
        var deltaX = lastPoint.X - firstPoint.X;
        var deltaTime = (lastPoint.Time - firstPoint.Time).TotalMilliseconds;

        // Avoid division by zero
        if (deltaTime < 1)
        {
            return 0;
        }

        return deltaX / deltaTime; // pixels per millisecond
    }

    private void UpdateFilmstripOffset()
    {
        var viewportWidth = DisplaySettings.Width;
        var baseOffset = -(currentPageIndex + 1) * viewportWidth;
        filmstripOffset = baseOffset + dragOffset;
    }

    private async Task AnimateToPage(int targetIndex)
    {
        _animationCts = new CancellationTokenSource();
        var token = _animationCts.Token;
        isAnimating = true;

        var startOffset = filmstripOffset;
        var viewportWidth = DisplaySettings.Width;
        var endOffset = -(targetIndex + 1) * viewportWidth;

        var duration = 300; // ms
        var startTime = DateTime.Now;

        while ((DateTime.Now - startTime).TotalMilliseconds < duration)
        {
            if (token.IsCancellationRequested)
            {
                // Animation was interrupted by a new touch.
                // The filmstripOffset remains where it was, and we exit.
                return;
            }

            var elapsed = (DateTime.Now - startTime).TotalMilliseconds;
            var progress = elapsed / duration;
            // Use ease-out cubic for smooth deceleration
            var easedProgress = 1 - Math.Pow(1 - progress, 3);

            filmstripOffset = startOffset + (endOffset - startOffset) * easedProgress;

            StateHasChanged();
            await Task.Delay(16); // ~60fps
        }

        // Finalize state only if animation completes without cancellation
        currentPageIndex = targetIndex;
        dragOffset = 0;
        filmstripOffset = endOffset;
        isAnimating = false;
        StateHasChanged();
    }

    // --- MOUSE EVENT HANDLERS (for desktop testing) ---
    private bool isMouseDown = false;

    private void HandleMouseDown(MouseEventArgs e)
    {
        // Cancel any ongoing animation
        if (isAnimating)
        {
            _animationCts?.Cancel();
            isAnimating = false;
        }

        isMouseDown = true;
        isDragging = true;

        // The new touch start position is the current mouse position
        touchStartX = e.ClientX / DisplaySettings.SCALEFACTOR;

        // The filmstrip's current position becomes the new baseline.
        var viewportWidth = DisplaySettings.Width;
        currentPageIndex = (int)Math.Round((-filmstripOffset / viewportWidth) - 1);

        // The drag offset starts from zero relative to the interrupted position.
        dragOffset = 0;

        touchStartTime = DateTime.Now;

        // Initialize touch point tracking
        recentTouchPoints.Clear();
        recentTouchPoints.Add(new TouchPoint { X = touchStartX, Time = DateTime.Now });
    }

    private void HandleMouseMove(MouseEventArgs e)
    {
        if (!isMouseDown || !isDragging) return;

        touchCurrentX = e.ClientX / DisplaySettings.SCALEFACTOR;
        var rawOffset = touchCurrentX - touchStartX;

        // Track position for velocity calculation
        var now = DateTime.Now;
        recentTouchPoints.Add(new TouchPoint { X = touchCurrentX, Time = now });

        // Keep only recent points
        if (recentTouchPoints.Count > MaxTouchPointHistory)
        {
            recentTouchPoints.RemoveAt(0);
        }

        // Apply resistance at boundaries
        if ((rawOffset > 0 && currentPageIndex <= -1) || // Trying to go before spotlight
            (rawOffset < 0 && currentPageIndex >= Pages.Count - 1)) // Trying to go past last page
        {
            // Apply rubber-band resistance (reduce drag effect by 30%)
            dragOffset = rawOffset * 0.3;
        }
        else
        {
            dragOffset = rawOffset;
        }

        // Update UI during drag for smooth tracking
        UpdateFilmstripOffset();
        StateHasChanged();
    }

    private async void HandleMouseUp(MouseEventArgs e)
    {
        if (!isMouseDown || !isDragging) return;
        isMouseDown = false;
        isDragging = false;

        // Calculate velocity from recent movement
        var now = DateTime.Now;
        var velocity = CalculateVelocity(now);

        // Get viewport width for threshold calculation
        var viewportWidth = DisplaySettings.Width;
        var halfPage = viewportWidth / 2.0;

        // Determine if we should change pages
        // Only consider velocity if it's a fast flick (not a slow drag)
        var isFastFlick = Math.Abs(velocity) > 0.8;
        var shouldChangePage = Math.Abs(dragOffset) > halfPage || isFastFlick;

        var targetPageIndex = currentPageIndex;
        if (shouldChangePage)
        {
            if (dragOffset < 0 && currentPageIndex < Pages.Count - 1)
            {
                targetPageIndex++;
            }
            else if (dragOffset > 0 && currentPageIndex > -1)
            {
                targetPageIndex--;
            }
        }

        // Animate to the final position (either new page or back to current)
        await AnimateToPage(targetPageIndex);
    }
}