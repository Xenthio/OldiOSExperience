@using OldiOS.Shared.Models
@using OldiOS.Shared.Services
@using Microsoft.JSInterop
@inject SpringboardService SpringboardService
@inject BackgroundAppManager AppManager
@inject AnimationService AnimationService
@inject DisplaySettings DisplaySettings
@inject IJSRuntime JS
@implements IDisposable

<div class="springboard-container @(isAppOpen ? "app-is-open" : "") @(isAppSwitcherVisible ? "switcher-visible" : "") @(DebugAnimationActive ? "debug-animation" : "") @(isLocked ? "locked" : "") @(isUnlocking ? "unlocking" : "")"
     style="--icon-rows: @DisplaySettings.GetIconRows(); --icon-columns: @DisplaySettings.GetIconColumns();">
    <!-- Wallpaper -->
    <div class="wallpaper" alt="Wallpaper" />

    <!-- Status Bar -->
    <OldiOS.Shared.System.StatusBar Style="OldiOS.Shared.System.StatusBarStyle.WhiteOnBlackEtch" />

    <!-- Pages Container (the part that swipes) -->
    <div class="springboard-pages-container"
         @ontouchstart="HandleTouchStart"
         @ontouchmove="HandleTouchMove"
         @ontouchend="HandleTouchEnd"
         @onmousedown="HandleMouseDown"
         @onmousemove="HandleMouseMove"
         @onmouseup="HandleMouseUp"
         @onmouseleave="HandleMouseUp">

        <div class="springboard-pages-filmstrip" @ref="filmstripRef">
            <!-- Spotlight Page (index -1) -->
            <div class="springboard-page spotlight-container">
                <OldiOS.Shared.Pages.Springboard.Components.Spotlight AllApps="AllApps" />
            </div>

            <!-- Regular App Pages -->
            @foreach (var page in Pages)
            {
                <div class="springboard-page">
                    @foreach (var app in page)
                    {
                        <OldiOS.Shared.Pages.Springboard.Components.AppIcon App="app" OnAppClick="HandleAppClick" />
                    }
                </div>
            }
        </div>
    </div>

    <!-- Page Indicator Dots -->
    <div class="page-indicator">
        @for (int i = 0; i < Pages.Count; i++)
        {
            <div class="dot @(i == currentPageIndex ? "active" : "")"></div>
        }
    </div>

    <!-- The Dock -->
    <div class="dock">
        <div class="dock-background"></div>
        <div class="dock-icons">
            @foreach (var app in DockApps)
            {
                <OldiOS.Shared.Pages.Springboard.Components.AppIcon App="app" OnAppClick="HandleAppClick" InDock="true" />
            }
        </div>
    </div>

    <!-- App Container for launching apps -->
    <OldiOS.Shared.Pages.Springboard.Components.AppContainer CurrentApp="@openedApp" OnClose="CloseApp" @ref="appContainerRef" />

    <!-- App Switcher (multitasking tray) -->
    <OldiOS.Shared.Pages.Springboard.Components.AppSwitcher IsVisible="@isAppSwitcherVisible"
                                                            OnClose="HandleAppSwitcherClose"
                                                            OnAppSelected="HandleAppSwitcherSelect" />

    <!-- Lock Screen -->
    <OldiOS.Shared.Pages.Springboard.Components.LockScreen IsLocked="@isLocked" OnUnlocked="HandleUnlocked" />
</div>

@code {
    [Parameter]
    public bool DebugAnimationActive { get; set; } = false;

    private List<List<AppInfo>> Pages => SpringboardService.Pages;
    private List<AppInfo> DockApps => SpringboardService.DockApps;
    private List<AppInfo> AllApps => SpringboardService.AllApps;
    private AppInfo? openedApp => AppManager.ForegroundApp?.App;
    private bool isAppOpen => openedApp != null;

    private int currentPageIndex = 0; // 0 = first app page, -1 = spotlight
    private double touchStartX = 0;
    private double touchCurrentX = 0;
    private double dragOffset = 0;
    private double dragStartOffset = 0; // filmstrip offset at the moment drag starts/grabs
    private bool isDragging = false;
    private DateTime touchStartTime = DateTime.MinValue;
    private bool isAnimating = false;

    // New animation state
    private double filmstripOffset = 0;
    private CancellationTokenSource? _animationCts;

    // Touch velocity tracking (lower allocations)
    private struct TouchPoint { public double X; public double TimeMs; }
    private TouchPoint[] recentTouchPoints = new TouchPoint[10];
    private int touchPointCount = 0;
    private const double VelocityTimeWindowMs = 100;

    private bool isAppSwitcherVisible = false;
    private bool isLocked = true;
    private bool isUnlocking = false;

    private ElementReference filmstripRef;
    private OldiOS.Shared.Pages.Springboard.Components.AppContainer? appContainerRef;
    private IJSObjectReference? _animModule;
    private bool _suppressRender = false;
    private int _animModuleVersion = 1;

    protected override void OnInitialized()
    {
        SpringboardService.InitializeLayout();
        AppManager.OnAppStatesChanged += HandleAppStateChanged;
        DisplaySettings.OnResolutionChanged += HandleResolutionChanged;
        UpdateFilmstripOffset();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await EnsureJs();
            await SetFilmstripOffset(filmstripOffset, false);
        }
    }

    private async Task EnsureJs(bool forceReload = false)
    {
        if (forceReload)
        {
            _animModule = null;
            _animModuleVersion++;
        }
        if (_animModule == null)
        {
            // Load from static web assets of OldiOS.Shared with cache-busting version
            var path = $"./_content/OldiOS.Shared/js/springboardAnimation.js?v={_animModuleVersion}";
            _animModule = await JS.InvokeAsync<IJSObjectReference>("import", path);
        }
    }

    public void Dispose()
    {
        _animationCts?.Cancel();
        _animationCts?.Dispose();
        AppManager.OnAppStatesChanged -= HandleAppStateChanged;
        DisplaySettings.OnResolutionChanged -= HandleResolutionChanged;
        _ = _animModule?.DisposeAsync();
    }

    protected override bool ShouldRender() => !_suppressRender;

    private async Task SetFilmstripOffset(double px, bool requestFrame = true)
    {
        filmstripOffset = px;
        if (_animModule != null)
        {
            await _animModule.InvokeVoidAsync("setOffset", filmstripRef, px, requestFrame);
        }
    }

    [JSInvokable]
    public async Task OnAnimationCompleted(double finalOffset)
    {
        filmstripOffset = finalOffset;
        dragOffset = 0;
        isAnimating = false;
        _suppressRender = false;
        StateHasChanged();
        await Task.CompletedTask;
    }

    private void HandleResolutionChanged()
    {
        SpringboardService.InitializeLayout();
        UpdateFilmstripOffset();
        _ = SetFilmstripOffset(filmstripOffset, false);
        StateHasChanged();
    }

    private void HandleAppStateChanged() => StateHasChanged();

    private async void HandleUnlocked()
    {
        isUnlocking = true;
        StateHasChanged();
        await Task.Delay(400);
        isLocked = false;
        isUnlocking = false;
        StateHasChanged();
    }

    private void HandleAppSwitcherClose() { isAppSwitcherVisible = false; StateHasChanged(); }
    private void HandleAppSwitcherSelect(AppInfo app) { AppManager.LaunchApp(app); isAppSwitcherVisible = false; StateHasChanged(); }

    private void HandleAppClick(AppInfo app)
    {
        if (isDragging || isAnimating) return;
        SpringboardService.LaunchApp(app);
    }

    private void CloseApp() => AppManager.ReturnToSpringboard();

    public void HandleHomeButtonSinglePress() { if (isLocked) return; SpringboardService.HandleHomeButton(); StateHasChanged(); }
    public void HandleHomeButtonDoublePress()
    {
        if (isLocked) return;
        if (isAppOpen)
        {
            appContainerRef?.ShowAppSwitcher();
        }
        else
        {
            isAppSwitcherVisible = true;
            StateHasChanged();
        }
    }
    public void HandleHomeButtonLongPress() { if (isLocked) return; StateHasChanged(); }

    private async Task<double> CancelInFlightAnimationAsync()
    {
        await EnsureJs();
        try
        {
            var currentX = await _animModule!.InvokeAsync<double>("cancelAnimation", filmstripRef);
            isAnimating = false;
            dragOffset = 0;
            filmstripOffset = currentX;
            return currentX;
        }
        catch (JSException)
        {
            await EnsureJs(forceReload: true);
            var currentX = await _animModule!.InvokeAsync<double>("cancelAnimation", filmstripRef);
            isAnimating = false;
            dragOffset = 0;
            filmstripOffset = currentX;
            return currentX;
        }
    }

    private async Task HandleTouchStart(TouchEventArgs e)
    {
        if (isDragging) return;
        if (isAnimating)
        {
            var currentX = await CancelInFlightAnimationAsync();
            await SetFilmstripOffset(currentX, false);
        }
        isDragging = true;
        touchStartX = e.Touches[0].ClientX / DisplaySettings.SCALEFACTOR;
        dragStartOffset = filmstripOffset; // capture where we grabbed
        // do not change currentPageIndex here; drag uses absolute offset from grab
        dragOffset = 0;
        touchStartTime = DateTime.Now;
        touchPointCount = 0;
        AddTouchPoint(touchStartX);
    }

    private void HandleTouchMove(TouchEventArgs e)
    {
        if (!isDragging) return;
        touchCurrentX = e.Touches[0].ClientX / DisplaySettings.SCALEFACTOR;
        var rawOffset = touchCurrentX - touchStartX; // pixels moved since grab
        AddTouchPoint(touchCurrentX);

        var viewportWidth = DisplaySettings.Width;
        var min = -(Pages.Count) * viewportWidth; // right bound (most negative)
        var max = 0; // left bound
        var desired = dragStartOffset + rawOffset;

        double newOffset;
        if (desired > max)
            newOffset = max + (desired - max) * 0.3; // resistance left
        else if (desired < min)
            newOffset = min + (desired - min) * 0.3; // resistance right
        else
            newOffset = desired;

        dragOffset = rawOffset;
        _ = SetFilmstripOffset(newOffset, true);
    }

    private async void HandleTouchEnd(TouchEventArgs e)
    {
        if (!isDragging) return;
        isDragging = false;
        var velocity = CalculateVelocity();
        var viewportWidth = DisplaySettings.Width;
        var isFastFlick = Math.Abs(velocity) > 0.8;

        // Decide target from current offset so partial positions are respected
        var finalOffset = filmstripOffset; // already updated via setOffset
        var position = (-finalOffset / viewportWidth) - 1.0; // -1..N-1 continuous
        var target = (int)Math.Round(position);

        if (isFastFlick)
        {
            target += velocity < 0 ? 1 : -1; // left flick -> next page (more negative offset)
        }

        target = Math.Clamp(target, -1, Pages.Count - 1);
        await AnimateToPage(target);
    }

    private void AddTouchPoint(double x)
    {
        var nowMs = DateTime.UtcNow.Ticks / 10000.0; // ms
        if (touchPointCount < recentTouchPoints.Length) recentTouchPoints[touchPointCount++] = new TouchPoint { X = x, TimeMs = nowMs }; else
        {
            Array.Copy(recentTouchPoints, 1, recentTouchPoints, 0, recentTouchPoints.Length - 1);
            recentTouchPoints[^1] = new TouchPoint { X = x, TimeMs = nowMs };
            touchPointCount = recentTouchPoints.Length;
        }
    }

    private double CalculateVelocity()
    {
        if (touchPointCount < 2) return 0;
        var nowMs = DateTime.UtcNow.Ticks / 10000.0;
        var cutoff = nowMs - VelocityTimeWindowMs;
        int firstIndex = -1, lastIndex = touchPointCount - 1;
        for (int i = 0; i < touchPointCount; i++) { if (recentTouchPoints[i].TimeMs >= cutoff) { firstIndex = i; break; } }
        if (firstIndex == -1) firstIndex = 0;
        var first = recentTouchPoints[firstIndex];
        var last = recentTouchPoints[lastIndex];
        var deltaX = last.X - first.X;
        var deltaT = last.TimeMs - first.TimeMs;
        if (deltaT <= 0) return 0;
        return deltaX / deltaT; // px per ms
    }

    private void UpdateFilmstripOffset()
    {
        // Non-drag updates snap to the current page index (e.g., resolution change)
        var viewportWidth = DisplaySettings.Width;
        var baseOffset = -(currentPageIndex + 1) * viewportWidth;
        filmstripOffset = baseOffset + dragOffset;
    }

    private async Task AnimateToPage(int targetIndex)
    {
        _animationCts = new CancellationTokenSource();
        var token = _animationCts.Token;
        isAnimating = true;
        _suppressRender = true; // skip diffing during rAF animation
        var startOffset = filmstripOffset;
        var viewportWidth = DisplaySettings.Width;
        var endOffset = -(targetIndex + 1) * viewportWidth;
        currentPageIndex = targetIndex; // update indicator early
        _suppressRender = false; StateHasChanged(); _suppressRender = true; // one render for indicator
        await EnsureJs();
        await _animModule!.InvokeVoidAsync("animateTo", filmstripRef, startOffset, endOffset, 300, DotNetObjectReference.Create(this));
    }

    // Mouse handlers
    private bool isMouseDown = false;
    private async Task HandleMouseDown(MouseEventArgs e)
    {
        if (isDragging) return;
        if (isAnimating)
        {
            var currentX = await CancelInFlightAnimationAsync();
            await SetFilmstripOffset(currentX, false);
        }
        isMouseDown = true; isDragging = true;
        touchStartX = e.ClientX / DisplaySettings.SCALEFACTOR;
        dragStartOffset = filmstripOffset;
        dragOffset = 0;
        touchStartTime = DateTime.Now;
        touchPointCount = 0; AddTouchPoint(touchStartX);
    }
    private void HandleMouseMove(MouseEventArgs e)
    {
        if (!isMouseDown || !isDragging) return;
        touchCurrentX = e.ClientX / DisplaySettings.SCALEFACTOR;
        var rawOffset = touchCurrentX - touchStartX;
        AddTouchPoint(touchCurrentX);

        var viewportWidth = DisplaySettings.Width;
        var min = -(Pages.Count) * viewportWidth;
        var max = 0;
        var desired = dragStartOffset + rawOffset;

        double newOffset;
        if (desired > max)
            newOffset = max + (desired - max) * 0.3;
        else if (desired < min)
            newOffset = min + (desired - min) * 0.3;
        else
            newOffset = desired;

        dragOffset = rawOffset;
        _ = SetFilmstripOffset(newOffset, true);
    }
    private async void HandleMouseUp(MouseEventArgs e)
    {
        if (!isMouseDown || !isDragging) return;
        isMouseDown = false; isDragging = false;
        var velocity = CalculateVelocity();
        var viewportWidth = DisplaySettings.Width;
        var isFastFlick = Math.Abs(velocity) > 0.8;
        var finalOffset = filmstripOffset;
        var position = (-finalOffset / viewportWidth) - 1.0;
        var target = (int)Math.Round(position);
        if (isFastFlick)
        {
            target += velocity < 0 ? 1 : -1;
        }
        target = Math.Clamp(target, -1, Pages.Count - 1);
        await AnimateToPage(target);
    }
}