@using OldiOSExperience.Data
@using OldiOSExperience.Services
@using Microsoft.JSInterop
@inject AnimationService AnimationService
@inject IJSRuntime JSRuntime
@implements IDisposable

<div class="app-icon @GetAnimationClass()" 
     style="@GetAnimationStyle()"
     @ref="iconElement"
     @onclick="HandleClick">
    <img src="@App.IconPath" alt="@App.Name" />
    <span>@App.Name</span>
</div>

@code {
    [Parameter]
    public required AppInfo App { get; set; }
    
    [Parameter]
    public EventCallback<AppInfo> OnAppClick { get; set; }
    
    [Parameter]
    public bool IsInDock { get; set; } = false;
    
    private ElementReference iconElement;
    private double iconCenterX = 0;
    private double iconCenterY = 0;
    
    // Cached animation style to avoid recalculating on every render
    private string cachedAnimationStyle = "";
    
    protected override void OnInitialized()
    {
        AnimationService.OnAnimationStateChanged += HandleAnimationStateChanged;
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await CaptureIconPosition();
        }
    }
    
    private async Task CaptureIconPosition()
    {
        try
        {
            var rect = await JSRuntime.InvokeAsync<BoundingRect>("getElementBoundingRect", iconElement);
            iconCenterX = rect.Left + rect.Width / 2;
            iconCenterY = rect.Top + rect.Height / 2;
        }
        catch (JSException)
        {
            // JavaScript interop failed - element may not be rendered yet
            // Position will be recaptured on next render or click
            iconCenterX = 0;
            iconCenterY = 0;
        }
        catch (TaskCanceledException)
        {
            // Operation was cancelled - likely component disposed
            iconCenterX = 0;
            iconCenterY = 0;
        }
    }
    
    private async Task HandleClick()
    {
        // Capture the icon position for fly-away calculations
        await CaptureIconPosition();
        
        // Get the current page offset to calculate the visual center
        var pageOffset = await GetCurrentPageOffset();
        
        // iOS 5/6: Always animate from screen center (accounting for page scroll)
        // App zooms in from center, icons fly away from center
        AnimationService.StartOpeningAnimation(
            AnimationService.SCREEN_CENTER_X + pageOffset, 
            AnimationService.SCREEN_CENTER_Y);
        
        await OnAppClick.InvokeAsync(App);
    }
    
    private async Task<double> GetCurrentPageOffset()
    {
        try
        {
            // Get the filmstrip's horizontal scroll offset in pixels
            // This is used to calculate the visual center of the screen
            var offset = await JSRuntime.InvokeAsync<double>("getFilmstripOffset");
            return offset;
        }
        catch (JSException)
        {
            // JS interop failed - assume we're on first page (no offset)
            return 0;
        }
        catch (TaskCanceledException)
        {
            // Operation cancelled - assume we're on first page (no offset)
            return 0;
        }
    }
    
    private void HandleAnimationStateChanged()
    {
        // Recalculate animation style when animation state changes
        cachedAnimationStyle = CalculateAnimationStyle();
        StateHasChanged();
    }
    
    private string GetAnimationClass()
    {
        if (!AnimationService.IsAnimating) return "";
        
        return AnimationService.CurrentState switch
        {
            AnimationState.Opening => "fly-away",
            AnimationState.Closing => "fly-back",
            _ => ""
        };
    }
    
    private string GetAnimationStyle()
    {
        // Return cached style to avoid recalculating on every render
        return cachedAnimationStyle;
    }
    
    private string CalculateAnimationStyle()
    {
        if (!AnimationService.IsAnimating) return "";
        
        // If position wasn't captured, use screen center as fallback
        // This ensures animations always work even if JS interop fails
        double posX = iconCenterX != 0 ? iconCenterX : AnimationService.SCREEN_CENTER_X;
        double posY = iconCenterY != 0 ? iconCenterY : AnimationService.SCREEN_CENTER_Y;
        
        // Calculate distance and direction from the animation center point (screen center)
        double deltaX = posX - AnimationService.CenterX;
        double deltaY = posY - AnimationService.CenterY;
        double distance = Math.Sqrt(deltaX * deltaX + deltaY * deltaY);
        
        // Normalize to get direction
        double directionX = distance > 0 ? deltaX / distance : 0;
        double directionY = distance > 0 ? deltaY / distance : 0;
        
        // Fly away distance increases with distance from center
        double flyDistance = Math.Min(distance * 2, 800);
        
        // Both opening and closing use the same CSS custom properties
        return $"--fly-x: {flyDistance * directionX}px; --fly-y: {flyDistance * directionY}px;";
    }
    
    public void Dispose()
    {
        AnimationService.OnAnimationStateChanged -= HandleAnimationStateChanged;
    }
}